bean spring bean的注入过程
java8 高级特性（G1垃圾回收）
strem流式遍历和foreach，for循环效率
Synchronized和lock锁底层实现原理
synchronized锁方法，锁对象头，锁代码块的实现
synchronized锁升级过程
Lock CAS(比较并交换)
实际应用乐观锁，高并发情况下效率会不会很低
线程池（最好不要用Executors）
jvm调优
mysql，优化查询，索引为什么用B+树，不用平衡二叉树（树高太高，减少io），不用B树
Myisam和innodb的区别（数据备份上，myisam上全局锁）
一张表最多建多少个索引
redis的选用（为什么不用memcache和mongodb）
redis为什么这么快（内存，单线程（创建rdb会fork一个子线程））
redis集群
redis缓存击穿，缓存穿透
spring的优点是什么？？？？？？？ IOC AOP
dubbo调用链路，服务暴露过程
常见的设计模式
如何保证幂等,(避免重复支付)

HashMap数据结构 
  1.7和1.8的区别
  1.7使用数组加链表的结构，1.8是使用数组加链表加红黑树（链表长度超过8），entry节点插入链表的时候使用
  头插法插入，在扩容的时候，会创建一个新的entry空数组，长度是原来的2被，然后遍历原来的entry数组，
  把所有的entry重新hash到新数组中，hash规则是和他的长度有关的，使用头插法的时候，同一位置上新元素是
  放在链表的头部位置的，旧数组上同一条entry链的元素，通过重新计算索引位置后，被放到了新数组的不同位置，
  可能会出现环形链表，1.8之后是使用尾插法，扩容的时候会保证链表元素原本的顺序，不会出现环形链表
spring 事务隔离级别
   1）默认，使用数据库默认隔离级别
   2）读未提交。允许另外一个事务看到其他事务未提交的数据，产生脏读，不可重复读，幻读
   3）读已提交。一个事务提交的数据能被另外一个事务读取
   4）可重复读。
   5）串行化

 spring事务传播属性
    1）默认的是required，存在一个事务，则支持当前事务，没有事务则开启一个新的事务
    2）Mandatory支持当前事务。如果没有事务，则抛出异常
    3）never 以非事务方式执行。如果存在当前事务，则抛出异常
    4）not_supported 以非事务方式执行。如果存在当前事务，就把当前事务挂起
    5）supports 支持当前事务，如果当前没有事务，则以非事务方式执行
    6）nested （嵌套）支持当前事务，新增Savepoint点，与当前事务同步提交或回滚，内层事务依赖外层事务
      外层事务失败，会回滚内层事务所做的动作，而内层事务操作失败不会引起外层事务的回滚

spring aop实现机制
   aop是面向切面编程，业务之间共同调用的逻辑提取并封装为一个可复用的模块，减少重复代码，降低模块的耦合度。
   可用于日志，权限的校验等，aop是基于代理模式的，jdk动态代理(只能代理接口不能代理类)，CGlib动态代理；
   jdk动态代理要求被代理类必须实现一个接口，核心是InvocationHandler接口和Proxy类
    CGLIB动态代理底层使用了ASM（一个短小精悍的字节码操作框架）来操作字节码生成新的类，
    目标对象实现接口，默认采用jdk动态代理实现aop，也可以强制使用cglib，如果没有实现接口，则使用cglib
    切面(aspect)，通知(advice)，切点(pointcut),连接点(joinpoint)，目标对象(Target，需要被代理的类)，
    织入(Weaving)

java反射机制
   在运行状态中，对于任意一个类，都能获得这个类的所有属性和方法，对于任意一个对象都能够调用它的任意一个
   属性和方法
   反射在大多数情况下，性能并不是很好，先去方法区里面看它这个类有没有加载过，如果
   没有加载过会有一个类加载的过程，一定程度上影响性能，反射是一种解释操作，需要告诉
   jvm，希望它怎么做，比直接写代码，直接操作会慢一点
   spring的ioc底层实现就是反射机制，通过解析xml文件，获取id属性和class属性的内容，利用反射原理创建配置
   文件里类的实例对象，存入spring的容器中

nginx怎么实现负载均衡
  通过调度算法
  1）轮询，按时间顺序逐一分配到不同的后端服务器
  2）轮询权重 权重越大，分配到访问的概率越高
  3）ip_hash 同一个ip的固定访问一个后端服务器，解决动态网站session共享问题
  4）url_hash 按照访问的url的hash结果阿里分配请求，每个url定向到同一个后端服务器，提高缓存服务器的效率

tcp3次握手为什么，刚开始客户端需要向服务端报告要和他建立连接，让服务器知道自己有发送的能力
，服务器判断是否可以创建连接，告诉客户端自己的接收能力，客户端收到服务器的SYN+ACK包，向服务
器发送确认包，客户端和服务器进入ESTABLISHED状态，完成三次握手。
  4次挥手，
     第一次的时候，主动关闭方发送一个FIN告诉被动关闭方，不会向它发数据了
     第二次：被动关闭方收到Fin包后，发送要给ACK给对方
     第三次：被动关闭方发送一个FIN，告诉主动关闭方，他的数据也发送完了，
     不会再发数据了
     第四次：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到
     序号+1，到此完成4次挥手

dubbo/rpc框架原理
  rpc框架(远程过程调用协议)，每个服务在启动的时候会在注册中心注册（ip，端口，提供的服务列表），
  消费方启动时向注册中心订阅自己所需的服务，注册中心返回服务提供者地址列表给消费者（如果有变更，
  注册中心将基于长连接推送变更数据给消费者。），消费者从提供者地址列表中，基于软负载均衡算法，
  选一台提供者进行调用，调用失败再选另一台调用
  配置中心，网关，监控（统计服务的调用次数和调用时间的监控中心），链路跟踪
  dubbo所有节点都是连通的，通过优化降低网络调用的消耗